{
    "contents" : "\n\n#Jorge Ahumada. Tropical Ecology Assessment and Monitoring Network. Conservation International\n# Code developed on 2010/07/02 - 2010/12/01\n# require(TeachingDemos)\nrequire(reshape2)\nrequire(plyr)\nrequire(ggplot2)\n#script to process raw TEAM files and get them ready for analysis\nf.readin.fix.data<-function(){\n  require(lubridate)\n  data<-read.csv(file.choose(),h=T,skip=62)\n  data<-f.fix.data(data)\n  #make sure date info makes sense\n  data\n}\n\n\n#function to create binary matrices for all species at a site and sampling period. Matrix has a 1 if the species was seen in a day a 0 if not seen and NA if not sampled\n#The function requires data from one sampling event and will return a list composed of 0,1 matrices, one matrix for each species.\n\n#THIS FUNCTION WORKS WITH NEW TEAM DATA ONLY - do not use with legacy TEAM data\n# this works one year at a time. Separate data in different years first\nf.matrix.creator2<-function(data,year){\n  #results object\n  res<-list()\n  \n  #get the dimensions of the matrix\n  \n  #list if sanpling units\n  cams<-unique(data$camera_trap)\n  cams<-sort(cams)\n  rows<-length(cams)\n  species<-unique(data$binomial)\n  #start and end dates of sampling periods\n  data<-data[data$Sampling.Period==year,]\n  min<-min(data$camera_trap_start_date)\n  max<-max(data$camera_trap_end_date)\n  cols<-max-min+1\n  \n  #sampling period\n  date.header<-seq(from=min,to=max, by=\"days\")\n  mat<-matrix(NA,rows,cols,dimnames=list(cams,as.character(date.header)))\n  \n  #for all cameras, determine the open and close date and mark in the matrix\n  start.dates<-tapply(as.character(data$camera_trap_start_date),data$camera_trap,unique)\n  nms<-names(start.dates)\n  # start.dates<-ymd(start.dates)\n  names(start.dates)<-nms\n  end.dates<-tapply(as.character(data$camera_trap_end_date),data$camera_trap,unique)\n  # end.dates<-ymd(end.dates)\n  names(end.dates)<-nms\n  \n  #outline the sampling periods for each camera j\n  for(j in 1:length(start.dates)){\n    #for each camera beginning and end of sampling\n    low<-which(date.header==as.Date(start.dates[j], format = \"%Y-%m-%d\"))\n    hi<-which(date.header==as.Date(end.dates[j], format = \"%Y-%m-%d\"))\n    if(length(low)+length(hi)>0){\n      indx<-seq(from=low,to=hi)\n      mat[names(start.dates)[j],indx]<- 0\n    } else next\n  }\n  mat.template<-mat\n  #get the species\n  #species<-unique(data$bin)\n  #construct the matrix for each species i\n  for(i in 1:length(species)){\n    indx<-which(data$bin==species[i])\n    #dates and cameras when/where the species was photographed\n    dates<-data$photo_date2[indx]\n    cameras<-data$camera_trap[indx]\n    dates.cameras<-data.frame(dates,cameras)\n    #unique combination of dates and cameras \n    dates.cameras<-unique(dates.cameras)\n    #fill in the matrix\n    for(j in 1:length(dates.cameras[,1])){\n      col<-which(date.header==dates.cameras[j,1])\n      row<-which(cams==dates.cameras[j,2])\n      mat[row,col]<-1\n    }\n    mat.nas<-is.na(mat)\n    sum.nas<-apply(mat.nas,2,sum)\n    indx.nas<-which(sum.nas==rows)\n    if(length(indx.nas)>0){\n      mat<-mat[,-indx.nas]\n    }\n    \n    res<-c(res,list(mat))\n    #return the matrix to its original form\n    mat<-mat.template\n  }\n  \n  names(res)<-species\n  #res<-lapply(res,f.dum)\n  res\n  \n}\n\nf.check.NA.breaks<-function(vector){\n  notna<-which(!is.na(vector))\n  if(min(notna)+length(notna)-1==max(notna)) print(\"ok\")\n  else print(\"aggh\")\n}\n\nf.start.minus.end<-function(data){\n  data$End.Date-data$Start.Date\n}\nf.start<-function(data){\n  data$Start.Date\n}\nf.end<-function(data){\n  data$End.Date\n}\n\nf.picture.dates<-function(data){\n  data$Photo.Date\n}\nf.picture.span <-function(data){\n  max(data)-min(data)\n}\nf.picture.min<-function(data){\n  min(data)\n}\nf.picture.max<-function(data){\n  max(data)\n}\n#function to fix the start/stop time of a camera if it is incorrectly entered  \nf.start.stop.date.fixer<-function(data){\n  \n  cam.start.date<-by(data,data$camera_trap,f.start)\n  cam.start.date<-lapply(cam.start.date,unique)\n  cam.end.date<-by(data,data$camera_trap,f.end)\n  cam.end.date<-lapply(cam.end.date,unique)\n  \n  #cam.span<-(by(data,data$camera_trap,f.start.minus.end))\n  #cam.span<-lapply(cam.span,unique)\n  \n  pic.span<-by(data,data$camera_trap,f.picture.dates)\n  min.pic<-lapply(pic.span,f.picture.min)\n  max.pic<-lapply(pic.span,f.picture.max)\n  #pic.span<-lapply(pic.span,f.picture.span)\n  \n  indx<-which(as.numeric(cam.start.date)-as.numeric(min.pic)>0 |as.numeric(cam.end.date)-as.numeric(max.pic)<0)\n  #figure out which camera has the problem\n  #indx<-which(as.numeric(cam.span)-as.numeric(pic.span)<=0)\n  if(length(indx)){\n{cam.id<-names(pic.span)[indx]\n print(\"There are problems with the following cameras:\")\n print(cam.id)}\n#for(i in 1:length(indx)){\n#\tindex<-which(data$camera_trap==cam.id[i])\n#\tdata$Start.Date[index]<-min.pic[[indx[i]]]\n#\tdata$End.Date[index]<-max.pic[[indx[i]]]\n#\t\n#\t}\n  }\nelse\n  print(\"No problems detected..\")\n#data\n}\t\n#function to convert a list of sampling matrices generated by f.matrix.creator2 into a data frame that can be used by the unmarked package\t\nf.convert.to.unmarked<-function(list){\n  require(unmarked)\n  nspecies<-length(list)\n  nrows<-dim(list[[1]])[1]\n  ncols<-dim(list[[1]])[2]\n  oldmat<-list()\n  \n  for(i in 1:nspecies){\n    mat<-rbind(oldmat,list[[i]])\n    oldmat<-mat\n  }\t\n  y<-as.matrix(mat[,-ncols])\n  rownames(y)<-NULL\n  colnames(y)<-NULL\n  species<-gl(n=nspecies,k=nrows,labels=names(list))\n  siteCovs<-as.data.frame(species)\n  unmarkedFrameOccu(y=y,siteCovs=siteCovs)\t\n}\n\nf.correct.DF<-function(DF){\n  ind <- sapply(DF, is.factor)\n  DF[ind] <- lapply(DF[ind], \"[\", drop=TRUE)\n  DF\n}\n\n\nf.fix.data <- function(data){\n  require(lubridate)\n  #This function converts the dates and times in the data into date and time\n  data$Photo.Date<-ymd(as.character(data$Photo.Date))\n  data$Photo.Time<-hms(as.character(data$Photo.Time))\n  #this line stores the date and time info for each photo into a single object\n  time.date<-ymd_hms(paste(data$Photo.Date,data$Photo.Time,sep=\"\"))\n  #split the date from the time for the Camera start date and time\n  data$Camera.Start.Date.and.Time<-ymd_hms(as.character(data$Camera.Start.Date.and.Time))\n  qwe<-data$Camera.Start.Date.and.Time\n  qwe2<-ymd(paste(year(qwe),\"-\",month(qwe),\"-\",day(qwe),sep=\"\"))\n  data<-data.frame(data,Start.Date=qwe2)\n  \n  #Now do the same but for the End date and time of each camera trap\n  #qwe<-strsplit(as.character(data$Camera.End.Date.and.Time),\" \",fixed=T)\n  data$Camera.End.Date.and.Time<-ymd_hms(as.character(data$Camera.End.Date.and.Time))\n  qwe<-data$Camera.End.Date.and.Time\n  qwe2<-ymd(paste(year(qwe),\"-\",month(qwe),\"-\",day(qwe),sep=\"\"))\n  data<-data.frame(data,End.Date=qwe2)\n  #create new variable with binomial - genus species\n  bin<-paste(data$Genus,data$Species)\n  data<-data.frame(data,bin=bin,td.photo=time.date)\n  data\n}\n# This works with data downloaded from the database, not from the TEAM website\nf.fix.data2 <- function(data){\n  require(lubridate)\n  #This function converts the dates and times in the data into date and time\n  #data$Photo.Date<-ymd(as.character(data$Photo.Date))\n  #data$Photo.Time<-hms(as.character(data$Photo.Time))\n  #this line stores the date and time info for each photo into a single object\n  time.date<-ymd_hms(as.character(data$Photo.Taken.Time))\n  data$Photo.Date<-ymd(paste(year(time.date),\"-\",month(time.date),\"-\",day(time.date),sep=\"\"))\n  #split the date from the time for the Camera start date and time\n  data$Camera.Start.Date.and.Time<-ymd_hms(as.character(data$Camera.Start.Date.and.Time))\n  qwe<-data$Camera.Start.Date.and.Time\n  qwe2<-ymd(paste(year(qwe),\"-\",month(qwe),\"-\",day(qwe),sep=\"\"))\n  data<-data.frame(data,Start.Date=qwe2)\n  \n  #Now do the same but for the End date and time of each camera trap\n  #qwe<-strsplit(as.character(data$Camera.End.Date.and.Time),\" \",fixed=T)\n  data$Camera.End.Date.and.Time<-ymd_hms(as.character(data$Camera.End.Date.and.Time))\n  qwe<-data$Camera.End.Date.and.Time\n  qwe2<-ymd(paste(year(qwe),\"-\",month(qwe),\"-\",day(qwe),sep=\"\"))\n  data<-data.frame(data,End.Date=qwe2)\n  #create new variable with binomial - genus species\n  bin<-paste(data$Genus,data$Species)\n  data<-data.frame(data,bin=bin,td.photo=time.date)\n  data\n}\nf.dum<-function(data){\n  dum<-apply(data,1,sum,na.rm=T)\n  dum<-ifelse(dum>0,0,1)\n  data<-data.frame(data,dum=dum)\n  data\n}\nf.extract.rare.sp<-function(raredata,alldata){\n  spnum<-length(raredata[,1])\n  oldindx<-numeric()\n  for(i in 1:spnum){\n    \n    indx<-c(oldindx,which(alldata@siteCovs$species==as.character(raredata[i,1])))\n    oldindx<-indx\n  }\n  sp<-siteCovs(alldata)[indx,]\n  sp<-factor(sp)\n  newufframe<-unmarkedFrameOccu(y=getY(alldata)[indx,],siteCovs=data.frame(species=sp))\n  newufframe\n}\n\n#Separate independent photographic events for a species in a given camera trap and date. thresh gives the threshold for considering events separate\n#thresh is in minutes\nf.separate<-function(data,thresh){\n  \n  #diff(data$td.photo)\n  l<-length(data)\n  interval<-diff(data)#abs(c(data[2:l],NA)-data)\n  interval<-interval/60 #convert to minutes\n  interval<-as.numeric(interval)\n  ev<-1;res<-numeric()\n  cond<-interval>thresh #about 5 minutes in between events\n  for(i in 1:(l-1)){\n    if(!cond[i]) ev<-ev\n    else ev<-ev+1\n    res<-c(res,ev)\n    \n  }\n  c(1,res)\n}\n#test function; not usually used\t\nf.test.sep<-function(cond){\n  l<-length(cond)\n  #interval<-c(data$Photo.Time[2:l],NA)-data$Photo.Time\n  ev<-1;res<-numeric()\n  #cond<-interval>5\n  for(i in 1:(l-1)){\n    if(!cond[i]) ev<-ev\n    else ev<-ev+1\n    res<-c(res,ev)\n    \n  }\n  c(1,res)\n  \n  \n}\n\n#Order the data by Sampling unit name and photo raw name. This will order images chronologically\nf.order.data<-function(data){\n  indx<-order(data$Sampling.Period,data$camera_trap,data$Photo.Taken.Time)\n  data<-data[indx,]\n  data\n}\n#function to separate independent events, extract from the list and paste together with the data set.\n#This function removes records that are NOT images.. e.g. Sampling Date records\nf.separate.events<-function(data,thresh){\n  \n  #e.data<-by(data$td.photo,data$camera_trap,f.separate,thresh)\n  indx<-which(is.na(data$Photo.Taken.Time))\n  if(length(indx)>0)\n    data<-data[-indx,]\n  e.data<-f.separate(data$Photo.Taken.Time,thresh)\n  #e.data<-data.frame(grp=unlist(e.data))\n  data.frame(data,grp=paste(data$Sampling.Period,\".\",data$camera_trap,\".\",e.data,sep=\"\"))\n  \n}\n#Simulation to explore the effect of changing the threshold on the number\n# of independent events. Thresh range is given as a sequence in mins\nf.sim.thres<-function(data,threshRange){\n  qwe<-data[,-42]\n  res<-data.frame(thresh=threshRange,n.events=NA)\n  for(i in threshRange){\n    qwe<-f.separate.events(qwe,threshRange[i])\n    res[i,2]<-length(unique(qwe[,42]))\n    qwe<-qwe[,-42]\n    qwe<-f.correct.DF(qwe)\n  }\n  plot(res[,1],res[,2],xlab=\"Threshold (min)\",ylab=\"Number of events\",type='b')\n  res\n}\n\n#convert Farenheit to Celsius\n\nf.FtoC<-function(temp) {\n  round(5/9*(temp-32))\n}\n\n#extract temperatures for a given species and graph\nf.extract.temp<-function(data,species) {\n  qwe<-data[data$bin==species,]\n  qwe<-f.correct.DF(qwe)\n  res<-as.numeric(by(qwe$Temp,qwe$grp,mean))\n  res\n}\n\nf.graph.temp<-function(species,spname,nbins) {\n  par(lwd=2)\n  truehist(species,xlim=c(15,35),ylim=c(0,0.25),xlab=expression(paste(\"Temperature (\",degree,\"C)\",sep=\"\")),col=\"blue\",nbins=nbins)\n  abline(v=28.6,lty=2,lwd=3)\n  #abline(v=26.7,lwd=2)\n  title(spname)\n}\n\n#create code to separate variables for a single event\nf.events<-function(data){\n  temp<-mean(data$Temperature)\n  site<-unique(as.character(data$Site.Name))\n  date<-min(as.character(data$Photo.Date))\n  time<-min(as.character(data$Photo.Time))\n  sp<-unique(as.character(data$bin))\n  sun<-unique(as.character(data$camera_trap))\n  lat<-unique(data$Latitude)\n  lon<-unique(data$Longitude)\n  sap<-unique(data$Sampling.Period)\n  mp<-unique(data$Moon.Phase)\n  c(site,date,time,sap,temp,sp,sun,lat,lon,mp)\n}\n\n#code to put together dataframe with each redcord being an event\nf.events.dataframe<-function(data){\n  require(chron)\n  qwe<-by(data,data$grp,f.events)\n  qwe<-as.data.frame(do.call(\"rbind\",qwe))\n  names(qwe)<-c(\"Site.Name\",\"Date\",\"Time\",\"Sampling.Period\",\"Temperature\",\"bin\",\"camera_trap\",\"Latitude\",\"Longitude\",\"Moon.Phase\")\n  qwe$Date<-as.Date(chron(dates=as.character(qwe$Date),format=c(dates=\"y-m-d\")))\n  qwe$Time<-as.POSIXct(as.character(qwe$Time),format=\"%H:%M:%S\")\n  qwe$Temperature<-as.numeric(as.character(qwe$Temperature))\n  qwe$Latitude<-as.numeric(as.character(qwe$Latitude))\n  qwe$Longitude<-as.numeric(as.character(qwe$Longitude))\n  qwe$Moon.Phase<-as.numeric(as.character(qwe$Moon.Phase))\n  qwe\n}  \n\n#Code to create temperature event dataframes for a list of species.\n#puts them all in a list\n\nf.create.events.splist<-function(splist,fulldata){\n  results<-list()\n  for(i in 1:length(splist)){\n    #Extract the data\n    sp<-fulldata[fulldata$bin==splist[i],]\n    sp<-f.correct.DF(sp)\n    if(dim(sp)[1]<2){\n      print(paste(\"Species \",splist[i],\" has insufficient data..\",sep=\"\"))\n      results<-c(results,list(NULL))\n      next\n    }\n    #Order the data in chronological order\n    sp<-f.order.data(sp)\n    #Create independent observation events list with a threshold of 5 min\n    sp<-f.separate.events(sp,5) \n    #Create a simplified data frame with just the events\n    sp<-f.events.dataframe(sp)\n    results<-c(results,list(sp))\n    print(paste(\"Species \",splist[i],\" processed..\",sep=\"\"))\n  }\n  names(results)<-splist\n  results\n  \n}\nf.print.graphs<-function(data){\n  path=\"/Users/jorge/Analyses/TempTV/graphs2/\"\n  for(i in 1:length(data)) {\n    newp<-paste(path,names(data)[i],\".pdf\",sep=\"\")\n    pdf(newp)\n    qplot(Temperature,data=data[[i]],geom=\"histogram\",binwidth=1,main=names(data)[i])\n    ggsave(newp)\n  }  \n  \n}\n# funcion para asignar camaras faltantes que no tomaron fotos de animales.\n# SuName,startDate y endDate deben estar entre comillas. Los demas argumentos no.\n# startDate y endDate estan en format yyyy-mm-dd\nf.assign.missing<-function(SuName,SuPeriod,startDate,endDate,data){\n  rows<-dim(data)[1]\n  \n  #agregar Sampling Unit Name\n  data[rows+1,3]<-SuName\n  #agregar StartDate\n  data[rows+1,38]<-as.Date(startDate)\n  #agregar End Date\n  data[rows+1,39]<-as.Date(endDate)\n  #agregar sampling unit period\n  data[rows+1,6]<-SuPeriod\n  data\n  \n}\n\nf.minusBirds<-function(data){\n  indx<-which(data$Class==\"AVES\")\n  data<-data[-indx,]\n  data<-f.correct.DF(data)\n}\n#not reliable\n#code to shrink the matrix by half\n# f.shrink.matrix.half<-function(matrix){\n#   #if number of columns in the matrix is even\n#   if(!ncol(matrix)%%2){\n#     #figure out how many columns\n#     nc<-ncol(matrix)/2  \n#     #disagregate into individual matrices\n#     new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)\n#     old.cols<-seq(1,ncol(matrix),2)\n#     for(i in 1:nc){\n#       #sum the rows for the column sections\n#       sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum,na.rm=T)\n#       #convert to 0s and 1s\n#       new.matrix[,i]<-ifelse(sum.rows>=1,1,0)\n#     }  \n#     new.matrix\n#   }\n#   #if the number of columns is not even\n#   else{\n#     #store the first column in col1  \n#     col1<-matrix[,1]\n#     #convert the matrix to an even matrix\n#     matrix<-matrix[,-1]\n#     nc<-ncol(matrix)/2  \n#     #disagregate into individual matrices\n#     new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)\n#     old.cols<-seq(1,ncol(matrix),2)\n#     for(i in 1:nc){\n#       sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum,na.rm=T)\n#       new.matrix[,i]<-ifelse(sum.rows>=1,1,0)\n#     }\n#     cbind(col1,new.matrix)  \n#   }\n# }\n\n#collapseData<-f.shrink.matrix(testData)\n#umf2<-unmarkedFrameOccu(y=collapsedData)\n#umf2\n#fmcoll<-occu(~1 ~1,umf2)\n#summary(fmcoll)\n#plogis(coef(mod,\"det\"))\n#plogis(coef(mod,\"state\"))\n#plogis(coef(mod2,\"det\"))\n#plogis(coef(mod2,\"state\"))\n\n#code to shrink the matrix to exactly 15 columns\nf.shrink.matrix.to15<-function(matrix){\n  nc<-dim(matrix)[2]\n  if(!nc%%15){ # of the number of columns is exactly divisible by 15\n    newc<-nc%/%15\n    old.cols<-seq(1,nc,newc)\n    new.matrix<-matrix(NA,nr=nrow(matrix),nc=15)\n    for(i in 1:15){\n      new.matrix[,i]<-apply(matrix[,old.cols[i]:(old.cols[i]+newc-1)],1,max,na.rm=T)\n    }\n  } else{\n    rem<-nc%%15\n    newc<-nc%/%15\n    old.cols<-seq(1,nc-rem,newc)\n    new.matrix<-matrix(NA,nr=nrow(matrix),nc=15)\n    for(i in 1:14)\n      new.matrix[,i]<-apply(matrix[,old.cols[i]:(old.cols[i]+newc-1)],1,max,na.rm=T)\n    new.matrix[,15]<-apply(matrix[,old.cols[15]:nc],1,max,na.rm=T) \n  }\n  new.matrix[new.matrix==\"-Inf\"]<-NA\n  rownames(new.matrix)<-rownames(matrix)\n  new.matrix\n}\n\n\n#does not work\n#f.shrink.matrix<-function(matrix){\n\n#disagregate into individual matrices\n#nc<-length(seq(1,ncol(matrix),9))  \n#new.matrix<-matrix(NA,nr=nrow(matrix),nc=nc)\n#rownames(new.matrix)<-rownames(matrix)  \n#old.cols<-seq(1,ncol(matrix),9)\n#for(i in 1:nc){\n#sum the rows for the column sections\n#  sum.rows<-apply(matrix[,old.cols[i]:(old.cols[i]+1)],1,sum)\n#convert to 0s and 1s\n# new.matrix[,i]<-ifelse(sum.rows>=1,1,0)\n#}  \n#new.matrix\n#}\n\nf.plot.jag.res<-function(jags,species.name,model.name){\n  #naive occupancy\n  naive.occ<-apply(tmp,2,sum,na.rm=T)/apply(tmp,2,function(x){length(which(!is.na(x)))})\n  #plot results\n  mat<-jags$BUGSoutput$summary\n  #mean occupancy from model\n  m.occ<-jags$BUGSoutput$mean$psi\n  #median occupancy from model\n  med.occ<-jags$BUGSoutput$median$psi\n  #extract 95% confidence limits for occupancy\n  psiCol<-which(rownames(mat)==\"psi[1]\")\n  lo95ci<-mat[psiCol:(psiCol+3),3]\n  hi95ci<-mat[psiCol:(psiCol+3),7]\n  par(mfrow=c(2,1))\n  plot(2009:2012,m.occ,ylim=c(0,1),type='b',xlab=\"year\",ylab=\"occupancy\")\n  lines(2009:2012,as.numeric(lo95ci),lty=2)\n  lines(2009:2012,as.numeric(hi95ci),lty=2)\n  lines(2009:2012,naive.occ,col='red')\n  #lines(2007:2011,med.occ,lwd=3)\n  title(paste(species.name,\"\\n\",model.name))\n  \n  #graph lambda\n  lambdaCol<-which(rownames(mat)==\"lambda[1]\")\n  m.lambda<-mat[lambdaCol:(lambdaCol+2),1]\n  \n  lo95ci<-mat[lambdaCol:(lambdaCol+2),3]\n  hi95ci<-mat[lambdaCol:(lambdaCol+2),7]\n  plot(1:3,m.lambda,ylim=range(lo95ci,hi95ci),type='b',xlab=\"year interval\",ylab=\"lambda\")\n  lines(1:3,as.numeric(lo95ci),lty=2)\n  lines(1:3,as.numeric(hi95ci),lty=2)\n  abline(h=1,lty=3)\n  title(paste(species.name,\"\\n\",model.name))\n}\n\n# the function returns a reduced matrix collapsed using nday; if necessary, an X number of columns filled with NA are added\n# to adjust the size of the shrinked matrix; be careful that nday makes sense for the size of the matrix, so that\n# not many columns of NA are added \n\nshrink<-function(matrice,nday){\n  dy<-nday\n  while (dy < ncol(matrice)) {dy <- dy + nday}  \n  addcol<-dy-ncol(matrice)\n  if (addcol!=0) { \n    matNA<-matrix(NA,nrow=nrow(matrice),ncol=addcol)\n    matrice<-data.frame(matrice,matNA)}    \n  \n  period<-ncol(matrice)/nday\n  newday<-rep(1:period, each = nday)\n  \n  shr<-function (vec) {\n    nav<-is.na(vec)\n    dom<-all(nav==T)\n    if(dom==T) {y<-NA}\n    else {\n      abb<-sum(vec,na.rm=T)\n      y<-ifelse(abb==0,0,1)\n    }\n    return(y)\n  }\n  \n  matday<-data.frame(newday,t(matrice))\n  shrmat<-t(aggregate(matday[,-1],list(matday$newday),shr))\n  \n  return (shrmat[-1,]) \n}\n\n#put together the pres/absence matrices for multiple years for a particular species\n# starting with a list that has all matrices for each species for each year\nf.multyear.sp<-function(LIST,spn){\n  mats<-lapply(LIST,function(x) x[[spn]])\n  res<-array(dim=c(dim(mats[[1]])[1],dim(mats[[1]])[2],length(mats)))\n  for(i in 1:length(mats))\n    res[,,i]<-mats[[i]]\n  rownames(res)<-rownames(mats[[1]])\n  res\n}\n#HELPER functions in WPI analysis and rare species analyses\n#create some fake data for a species\n#that is rare\n\n#function to calculate the mode of a distribution\nf.mode<-function(data,na.rm=T){\n  qwe<-density(data,na.rm=T)\n  qwe$x[which(qwe$y==max(qwe$y))]\n  \n}\n\n#function to generate the WPI from the output simulations in JAGS\n# psi is a three dimensional matrix with the psi of each species in each year\nf.WPI <-function(psi){\n  nsim <- dim(psi)[1]\n  nyears <- dim(psi)[2]\n  nsp <- dim(psi)[3]\n  rel_psi<-numeric()\n  wpi<-matrix(NA,nr=nsim,nc=nyears)\n  for(i in 1:nsim){\n    for(t in 1:nyears){\n      for(s in 1:nsp){\n        rel_psi[s] <- log(psi[i,t,s]/psi[i,1,s])\n      }\n      wpi[i,t]<-exp(1/nsp*sum(rel_psi))\n    }\n  }\n  colnames(wpi)<-dimnames(psi)[[2]]\n  wpi\n  \n}\n#function to generate the WPI from the output simulations in JAGS\n# psi is a three dimensional matrix with the psi of each species in each year\n#this uses the odd ratio of psi/psi1 rather than the actual ration\nf.WPI2 <-function(psi){\n  nsim <- dim(psi)[1]\n  nyears <- dim(psi)[2]\n  nsp <- dim(psi)[3]\n  rel_psi<-numeric()\n  wpi<-matrix(NA,nr=nsim,nc=nyears)\n  for(i in 1:nsim){\n    for(t in 1:nyears){\n      for(s in 1:nsp){\n        rel_psi[s] <- log((psi[i,t,s]/(1-psi[i,t,s]+1/60/2))/(psi[i,1,s]/(1-psi[i,1,s]+1/60/2)))\n      }\n      wpi[i,t]<-exp(1/nsp*sum(rel_psi))\n    }\n  }\n  colnames(wpi)<-dimnames(psi)[[2]]\n  wpi\n  \n}\n#graph the WPI through time with 95% confidence limits\n#WPI is a matrix of n x t values (n = number of runs, t=number of years)\n#calculate with mean, mode or median\ngraph.WPI <- function(wpi,fun=mean,title){\n  require(TeachingDemos)\n  require(ggplot2)\n  year<-as.numeric(colnames(wpi))\n  FUN<-match.fun(fun)\n  ct<-apply(wpi,2,FUN,na.rm=T)\n  #int<-apply(wpi,2,emp.hpd)\n  lo50<-apply(wpi,2,quantile,0.25,na.rm=T)\n  hi50<-apply(wpi,2,quantile,0.75,na.rm=T)\n  conf75<-apply(wpi,2,quantile,c(0.125,1-0.125),na.rm=T)\n  res<-data.frame(year=year,ct=ct,lo50=lo50,hi50=hi50,lo75=conf75[1,],hi75=conf75[2,])\n  #res<-melt(res,id.vars=c('year'))\n  \n  p<-ggplot(data=res, aes(x=year))\n  p<-p+geom_line(aes(y=ct),size=2)\n  p<-p+geom_ribbon(aes(ymin=lo50,ymax=hi50),alpha=0.2)+geom_ribbon(aes(ymin=lo75,ymax=hi75),alpha=0.1)+xlab(\"Year\")+ylab(\"Wildlife Picture Index\")+labs(title=\"\")+geom_hline(yintercept=1,size=0.5,linetype=2) +labs(title=title)+ylim(0,10)\n  p\n  \n  #ggsave(\"SpeciesRichness.pdf\",p,width=15,height=8,units=\"cm\")\n}\n\ngraph.psi <- function(psi,initial,fun=mean,title=\"\",low=0.025,high=0.975,path=\"\"){\n  \n  require(ggplot2)\n  year<-as.numeric(colnames(psi))\n  FUN<-match.fun(fun)\n  ct<-apply(psi,2,FUN)\n  lo<-apply(psi,2,quantile,low)\n  hi<-apply(psi,2,quantile,high)\n  naive<-initial\n  #naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))\n  res<-data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)\n  #res<-melt(res,id.vars=c('year'))\n  \n  p<-ggplot(data=res, aes(x=year))\n  p<-p+geom_line(aes(y=ct),size=2)+geom_point(aes(y=naive),size=3)\n  p<-p+geom_ribbon(aes(ymin=lo,ymax=hi),alpha=0.2)+xlab(\"Year\")+ylab(\"Occupancy\")+ labs(title=\"\")+ ylim(0,1)+labs(title=title)\n  #p\n  \n  ggsave(paste(path,\"/Occ_\",title,\".pdf\",sep=\"\"),p,width=15,height=8,units=\"cm\")\n}\n\ngraph.psi2 <- function(psifit,title){\n  \n  require(ggplot2)\n  #year<-as.numeric(colnames(psi))\n  #FUN<-match.fun(fun)\n  #ct<-apply(psi,2,FUN)\n  #lo<-apply(psi,2,quantile,0.025)\n  #hi<-apply(psi,2,quantile,0.975)\n  #naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))\n  #res<-data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)\n  #res<-melt(res,id.vars=c('year'))\n  \n  p<-ggplot(data=psifit, aes(x=year))\n  p<-p+geom_line(aes(y=ct),size=2)+geom_point(aes(y=naive),size=3)\n  p<-p+geom_ribbon(aes(ymin=lo,ymax=hi),alpha=0.2)+xlab(\"Year\")+ylab(\"Occupancy\")+ labs(title=\"\")+ ylim(0,1)+labs(title=title)\n  p\n  \n  #ggsave(paste(\"Occ_\",title,\".pdf\",sep=\"\"),p,width=15,height=8,units=\"cm\")\n}\n#function to check for posterior predictive checks\n\nf.ppc<-function(model){\n  fit<-model$BUGSoutput$sims.list$fit\n  fit.new<-model$BUGSoutput$sims.list$fit.new\n  plot(fit,fit.new)\n  abline(0,1)\n  return(mean(fit.new>fit))\n  \n}\nf.calc.psi<-function(psi,initial,fun=mean){\n  year<-as.numeric(colnames(psi))\n  FUN<-match.fun(fun)\n  ct<-apply(psi,2,FUN)\n  lo<-apply(psi,2,quantile,0.025)\n  hi<-apply(psi,2,quantile,0.975)\n  naive<-apply(initial,2,function(x) sum(x,na.rm=T)/sum(!is.na(x)))\n  data.frame(year=year,ct=ct,lo=lo,hi=hi,naive=naive)\n  \n}\n\nf.load.fitted<-function(path){\n  load(path)\n  temp2<-temp\n  temp2\n}\n#This function takes a wpi object (matrix of n iterations by y years)\n# and calculates lambda with confidence limits\nf.calc.lambda<-function(wpi){\n  years<-dim(wpi)[2]\n  lambda<-matrix(NA,nr=dim(wpi)[1],nc=years-1)\n  for(i in 2:years)\n    lambda[,i-1]<-wpi[,i]/wpi[,i-1]\n  mean<-apply(lambda,2,mean)\n  conf<-apply(lambda,2,quantile,c(0.025,0.975))\n  data.frame(year=dimnames(wpi)[[2]][2:years],mean.lambda=mean,lo95=conf[1,],hi95=conf[2,])\n  \n}\n\nextractSpeciesObsOcc <-function(list){\n  #Extract species observed occupancy from a list that has nyear elements\n  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps \n  years<-names(list)\n  sp.names<-names(list[[1]])  \n  n.years<-length(years)  \n  n.sp<-length(sp.names)\n  \n  results.matrix<-matrix(NA,nr=n.sp,nc=n.years)\n  for (i in 1:n.years){\n    results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateObsOcc))\n    \n  }\n  colnames(results.matrix) <- years\n  rownames(results.matrix) <- sp.names\n  results.matrix\n  \n}\n\ncalculateObsOcc<-function(matrix){\n  pres.abs<-apply(matrix,1,max,na.rm=T)\n  pres.abs[is.infinite(pres.abs)] <- NA\n  n.cam<-sum(!is.na(pres.abs))\n  sum(pres.abs, na.rm=T)/n.cam\n  \n}\nextractSpeciesDetections <-function(list){\n  #Extract species detections from a list that has nyear elements\n  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps \n  years<-names(list)\n  sp.names<-names(list[[1]])  \n  n.years<-length(years)  \n  n.sp<-length(sp.names)\n  \n  results.matrix<-matrix(NA,nr=n.sp,nc=n.years)\n  for (i in 1:n.years){\n    results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateObsDet))\n    \n  }\n  colnames(results.matrix) <- years\n  rownames(results.matrix) <- sp.names\n  results.matrix\n  \n}\ncalculateObsDet<-function(matrix){\n  pres.abs<-apply(matrix,1,max,na.rm=T)\n  pres.abs[is.infinite(pres.abs)] <- NA\n  sum(pres.abs, na.rm=T)\n  \n}\nextractNumCameraTraps <-function(list){\n  #Extract number of camera traps used from a list that has nyear elements\n  #each element is contanins nsp matrices (ncameras x 15) with presence/absence data at different #camera traps \n  years<-names(list)\n  sp.names<-names(list[[1]])  \n  n.years<-length(years)  \n  n.sp<-length(sp.names)\n  \n  results.matrix<-matrix(NA,nr=n.sp,nc=n.years)\n  for (i in 1:n.years){\n    results.matrix[ ,i] <- as.numeric(lapply(list[[i]], calculateNumCameraTraps))\n    \n  }\n  colnames(results.matrix) <- years\n  rownames(results.matrix) <- sp.names\n  results.matrix\n  \n}\ncalculateNumCameraTraps<-function(matrix){\n  pres.abs<-apply(matrix,1,max,na.rm=T)\n  pres.abs[is.infinite(pres.abs)] <- NA\n  sum(!is.na(pres.abs))\n}\n\ncalculateWPIDiagnostics <- function(site.name){\n  # This function compares the observed occupancy with the fitted occupancy\n  # coming from the WPI analytics system\n  # It requires a vector with the names of the sites (site.names) and\n  # assumes that the whole camera trap data set is in the workspace (data)\n  # and an object with the fitted results (wpi)\n  results<-data.frame(site=character(),species=character(),\n                      tot.dets=numeric(),\n                      dets.per.year=numeric(),\n                      overall.occ=numeric(),\n                      diff.obs.mode=numeric(),\n                      diff.obs.median=numeric(),\n                      stringsAsFactors=F)     \n  #for(j in 1:length(site.names)){\n  path<-as.character(site.name)\n  dir.create(path)\n  #Extract data for site j\n  s.data<-subset(x=data,Site.Name==site.name,drop=T)\n  # take care of some things with the data\n  s.data<-f.fix.data2(s.data)\n  nyears<-length(year<-sort(as.numeric(unique(s.data$Sampling.Period))))\n  #create raw occupancy matrices\n  mat<-list()\n  for(i in 1:nyears)\n    mat[[i]]<-f.matrix.creator2(s.data,year[i])  \n  names(mat)<-year\n  #Compress the matrices\n  shmat<-list()\n  for(i in 1:nyears)\n    shmat[[i]]<-lapply(mat[[i]],FUN=f.shrink.matrix.to15)\n  names(shmat)<-year\n  #Extract species observed occupancy\n  obs.occ.matrix<-extractSpeciesObsOcc(shmat)\n  obs.det.matrix<-extractSpeciesDetections(shmat)\n  obs.cams.matrix<-extractNumCameraTraps(shmat)\n  \n  #Extract a site and species and graph the results\n  s.wpi<-subset(wpi,site_name==site.name,drop=T)\n  #do it for one species\n  \n  s.sp.list<-unique(s.wpi$bin)\n  \n  indx <- which(s.sp.list %in% rownames(obs.occ.matrix))\n  s.sp.list <- s.sp.list[indx] \n  \n  \n  for(i in 1:length(s.sp.list)){\n    #i <- 1\n    #j <- 5\n    \n    sp<-subset(x=s.wpi,bin==s.sp.list[i],drop=T)\n    #turn into a matrix so I can graph it\n    sp <- acast(sp, iteration~year, value.var=\"psi\")\n    #calculate mode, median and confidence intervals\n    occ.mode<-apply(sp,2,f.mode)\n    occ.median<-apply(sp,2,median)\n    #lo<-apply(sp,2,quantile,c(0.1,0.9))\n    #hi<-apply(sp,2,quantile,c(0.1,0.9))\n    #calculate observed annual occupancy ()\n    obs.occ <- obs.occ.matrix[s.sp.list[i],]\n    #calculate observed number of detections per year\n    obs.dets.per.year <- obs.det.matrix[s.sp.list[i],]\n    #calculate total number of detections\n    tot.dets <- sum(obs.det.matrix[s.sp.list[i],])\n    #calculate mean number of detections\n    dets.per.year <- tot.dets/nyears\n    #calculate observed overall occupancy (for the whole time period)\n    obs.all.occ <- sum(obs.det.matrix[s.sp.list[i],])/sum(obs.cams.matrix[s.sp.list[i],])\n    #calculate distance between observed and fitted mode\n    diff.obs.mode <- occ.mode - obs.occ\n    #calculate distance between observed and fitted median\n    diff.obs.median <- occ.median - obs.occ\n    #calculate mean distance between observed and fitted mode\n    mean.diff.obs.mode <- mean(diff.obs.mode, na.rm=T)\n    #calculate mean distance between observed and fitted median\n    mean.diff.obs.median <- mean(diff.obs.median, na.rm=T)\n    #put everything together in a data frame\n    temp <- c(as.character(site.name),s.sp.list[i], tot.dets,\n              dets.per.year,\n              obs.all.occ,\n              mean.diff.obs.mode,\n              mean.diff.obs.median)\n    results[nrow(results)+1, ] <- temp                      \n    \n    graph.psi(title=paste(s.sp.list[i],\"_\",site.name),psi=sp,initial=obs.occ.matrix[s.sp.list[i],],fun=median,low=0.1,hi=0.9,path=path)\n    print(paste(\"Done with species \",s.sp.list[i]))\n  }\n  results\n}\n\n#########################################\n### new\n#########################################\n\n#### sampling year:\nyear<-2014\n\nf.matrix.creator3 <- function(data,year){\n  #results object\n  res<-list()\n  \n  #get the dimensions of the matrix\n  \n  #list if sanpling units\n  cams<-unique(data$camera_trap)\n  cams<-sort(cams)\n  rows<-length(cams)\n  species<-unique(data$binomial)\n  #start and end dates of sampling periods\n  data<-data[data$Sampling.Period==year,]\n  min<-min(data$camera_trap_start_date)\n  max<-max(data$camera_trap_end_date)\n  cols<-max-min+1\n  \n  #sampling period\n  date.header<-seq(from=min,to=max, by=\"days\")\n  mat<-matrix(NA,rows,cols,dimnames=list(cams,as.character(date.header)))\n  \n  #for all cameras, determine the open and close date and mark in the matrix\n  start.dates<-  tapply(as.character(data$camera_trap_start_date),data$camera_trap,unique)\n  nms<-names(start.dates)\n  start.dates<-ymd(start.dates)\n  names(start.dates)<-nms\n  end.dates<-tapply(as.character(data$camera_trap_end_date),data$camera_trap,unique)\n  end.dates<-ymd(end.dates)\n  names(end.dates)<-nms\n  \n  #outline the sampling periods for each camera j\n  for(j in 1:length(start.dates)){\n    #for each camera beginning and end of sampling\n    low<-which(date.header==start.dates[j])\n    hi<-which(date.header==end.dates[j])\n    if(length(low)+length(hi)>0){\n      indx<-seq(from=low,to=hi)\n      mat[names(start.dates)[j],indx]<-0\n    } else next\n  }\n  mat.template<-mat\n  #get the species\n  #species<-unique(data$binomial)\n  #construct the matrix for each species i\n  for(i in 1:length(species)){\n    indx<-which(data$binomial==species[i])\n    #dates and cameras when/where the species was photographed\n    dates<-data$photo_date2[indx]\n    cameras<-data$camera_trap[indx]\n    dates.cameras<-data.frame(dates,cameras)\n    #unique combination of dates and cameras \n    dates.cameras<-unique(dates.cameras)\n    #fill in the matrix\n    for(j in 1:length(dates.cameras[,1])){\n      col<-which(date.header==dates.cameras[j,1])\n      row<-which(cams==dates.cameras[j,2])\n      mat[row,col]<-1\n    }\n    mat.nas<-is.na(mat)\n    sum.nas<-apply(mat.nas,2,sum)\n    indx.nas<-which(sum.nas==rows)\n    if(length(indx.nas)>0){\n      mat<-mat[,-indx.nas]\n    }\n    \n    res<-c(res,list(mat))\n    #return the matrix to its original form\n    mat<-mat.template\n  }\n  \n  names(res)<-species\n  #res<-lapply(res,f.dum)\n  res\n  \n}\n\n##############################################\n",
    "created" : 1437685952488.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2767351290",
    "id" : "55856B89",
    "lastKnownWriteTime" : 1430855477,
    "path" : "~/CodigoR/ULEAM/Infor_Caract/code/TEAM_code.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "type" : "r_source"
}